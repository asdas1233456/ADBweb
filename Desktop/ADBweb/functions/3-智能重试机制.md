# 3. æ™ºèƒ½é‡è¯•æœºåˆ¶

## ğŸ“Œ åŠŸèƒ½æ¦‚è¿°

**ç°çŠ¶**: ä»»åŠ¡å¤±è´¥åéœ€è¦æ‰‹åŠ¨é‡æ–°æ‰§è¡Œ  
**ç›®æ ‡**: æä¾›æ™ºèƒ½çš„è‡ªåŠ¨é‡è¯•æœºåˆ¶

## ğŸ¯ ä¸šåŠ¡ä»·å€¼

- å‡å°‘å› ç½‘ç»œæŠ–åŠ¨ã€ä¸´æ—¶å¡é¡¿å¯¼è‡´çš„è¯¯æŠ¥ï¼ˆæå‡30%æˆåŠŸç‡ï¼‰
- èŠ‚çœäººå·¥é‡è¯•æ—¶é—´ï¼ˆæ¯å¤©èŠ‚çœ2-3å°æ—¶ï¼‰
- æå‡æµ‹è¯•å¯é æ€§å’Œç”¨æˆ·ä½“éªŒ

## ğŸ“Š åŠŸèƒ½åˆ—è¡¨

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | å®ç°éš¾åº¦ | é¢„è®¡å·¥æ—¶ |
|------|--------|---------|---------|
| å¤±è´¥è‡ªåŠ¨é‡è¯• | P0 | ç®€å• | 3å°æ—¶ |
| æ™ºèƒ½é‡è¯•ç­–ç•¥ | P0 | ä¸­ç­‰ | 4å°æ—¶ |
| é‡è¯•é—´éš”é…ç½® | P1 | ç®€å• | 2å°æ—¶ |
| é‡è¯•å†å²è®°å½• | P1 | ç®€å• | 2å°æ—¶ |
| é‡è¯•é€šçŸ¥ | P2 | ç®€å• | 2å°æ—¶ |

## ğŸ”§ æŠ€æœ¯å®ç°æ–¹æ¡ˆ

### 3.1 æ•°æ®æ¨¡å‹è®¾è®¡

**æ‰©å±• TaskLog æ¨¡å‹**

```python
# backend/app/models/task_log.py

class TaskLog(SQLModel, table=True):
    """ä»»åŠ¡æ—¥å¿—"""
    __tablename__ = "task_logs"
    
    # ... åŸæœ‰å­—æ®µ
    
    # é‡è¯•ç›¸å…³å­—æ®µ
    retry_count: int = 0  # å·²é‡è¯•æ¬¡æ•°
    max_retry: int = 3  # æœ€å¤§é‡è¯•æ¬¡æ•°
    retry_enabled: bool = True  # æ˜¯å¦å¯ç”¨é‡è¯•
    retry_interval: int = 5  # é‡è¯•é—´éš”ï¼ˆç§’ï¼‰
    parent_task_id: Optional[int] = None  # çˆ¶ä»»åŠ¡IDï¼ˆé‡è¯•ä»»åŠ¡å…³è”åŸä»»åŠ¡ï¼‰
    is_retry: bool = False  # æ˜¯å¦ä¸ºé‡è¯•ä»»åŠ¡
    retry_reason: Optional[str] = None  # é‡è¯•åŸå› 
```

**æ–°å¢é‡è¯•é…ç½®æ¨¡å‹**

```python
# backend/app/models/retry_config.py

from sqlmodel import SQLModel, Field
from typing import Optional
from datetime import datetime

class RetryConfig(SQLModel, table=True):
    """é‡è¯•é…ç½®"""
    __tablename__ = "retry_configs"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    
    # å…¨å±€é…ç½®
    enabled: bool = True  # æ˜¯å¦å¯ç”¨é‡è¯•
    max_retry: int = 3  # é»˜è®¤æœ€å¤§é‡è¯•æ¬¡æ•°
    retry_interval: int = 5  # é»˜è®¤é‡è¯•é—´éš”ï¼ˆç§’ï¼‰
    
    # æ™ºèƒ½é‡è¯•ç­–ç•¥
    retry_on_timeout: bool = True  # è¶…æ—¶æ—¶é‡è¯•
    retry_on_network_error: bool = True  # ç½‘ç»œé”™è¯¯æ—¶é‡è¯•
    retry_on_element_not_found: bool = True  # å…ƒç´ æœªæ‰¾åˆ°æ—¶é‡è¯•
    retry_on_device_disconnected: bool = False  # è®¾å¤‡æ–­å¼€æ—¶ä¸é‡è¯•
    retry_on_app_crash: bool = False  # åº”ç”¨å´©æºƒæ—¶ä¸é‡è¯•
    retry_on_permission_denied: bool = False  # æƒé™æ‹’ç»æ—¶ä¸é‡è¯•
    retry_on_script_error: bool = False  # è„šæœ¬é”™è¯¯æ—¶ä¸é‡è¯•
    
    # é«˜çº§é…ç½®
    exponential_backoff: bool = True  # æŒ‡æ•°é€€é¿ï¼ˆé‡è¯•é—´éš”é€’å¢ï¼‰
    max_retry_interval: int = 60  # æœ€å¤§é‡è¯•é—´éš”ï¼ˆç§’ï¼‰
    
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)


class RetryHistory(SQLModel, table=True):
    """é‡è¯•å†å²è®°å½•"""
    __tablename__ = "retry_histories"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    task_log_id: int = Field(foreign_key="task_logs.id", index=True)
    retry_number: int  # ç¬¬å‡ æ¬¡é‡è¯•
    retry_reason: str  # é‡è¯•åŸå› 
    retry_time: datetime = Field(default_factory=datetime.now)
    result: str  # é‡è¯•ç»“æœ: success/failed
    error_message: Optional[str] = None
```

### 3.2 é‡è¯•ç­–ç•¥æœåŠ¡

```python
# backend/app/services/retry_service.py

from sqlmodel import Session, select
from app.models.task_log import TaskLog
from app.models.retry_config import RetryConfig, RetryHistory
from app.models.failure_analysis import FailureAnalysis
import asyncio
import logging

logger = logging.getLogger(__name__)

class RetryService:
    def __init__(self, db: Session):
        self.db = db
        self.config = self._load_config()
    
    def _load_config(self) -> RetryConfig:
        """åŠ è½½é‡è¯•é…ç½®"""
        statement = select(RetryConfig).limit(1)
        config = self.db.exec(statement).first()
        
        if not config:
            # åˆ›å»ºé»˜è®¤é…ç½®
            config = RetryConfig()
            self.db.add(config)
            self.db.commit()
            self.db.refresh(config)
        
        return config
    
    def should_retry(self, task_log: TaskLog, failure_type: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•"""
        # 1. æ£€æŸ¥æ˜¯å¦å¯ç”¨é‡è¯•
        if not self.config.enabled or not task_log.retry_enabled:
            logger.info(f"ä»»åŠ¡ {task_log.id} é‡è¯•æœªå¯ç”¨")
            return False
        
        # 2. æ£€æŸ¥é‡è¯•æ¬¡æ•°
        if task_log.retry_count >= task_log.max_retry:
            logger.info(f"ä»»åŠ¡ {task_log.id} å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° {task_log.max_retry}")
            return False
        
        # 3. æ ¹æ®å¤±è´¥ç±»å‹åˆ¤æ–­æ˜¯å¦é‡è¯•
        retry_map = {
            "timeout": self.config.retry_on_timeout,
            "network_error": self.config.retry_on_network_error,
            "element_not_found": self.config.retry_on_element_not_found,
            "device_disconnected": self.config.retry_on_device_disconnected,
            "app_crash": self.config.retry_on_app_crash,
            "permission_denied": self.config.retry_on_permission_denied,
            "script_error": self.config.retry_on_script_error,
        }
        
        should_retry = retry_map.get(failure_type, False)
        logger.info(f"ä»»åŠ¡ {task_log.id} å¤±è´¥ç±»å‹ {failure_type}, æ˜¯å¦é‡è¯•: {should_retry}")
        
        return should_retry
    
    def calculate_retry_interval(self, retry_count: int) -> int:
        """è®¡ç®—é‡è¯•é—´éš”"""
        if not self.config.exponential_backoff:
            return self.config.retry_interval
        
        # æŒ‡æ•°é€€é¿: interval * 2^retry_count
        interval = self.config.retry_interval * (2 ** retry_count)
        
        # é™åˆ¶æœ€å¤§é—´éš”
        return min(interval, self.config.max_retry_interval)
    
    async def retry_task(self, task_log: TaskLog, failure_type: str):
        """é‡è¯•ä»»åŠ¡"""
        # 1. åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•
        if not self.should_retry(task_log, failure_type):
            logger.info(f"ä»»åŠ¡ {task_log.id} ä¸æ»¡è¶³é‡è¯•æ¡ä»¶")
            return
        
        # 2. è®¡ç®—é‡è¯•é—´éš”
        retry_interval = self.calculate_retry_interval(task_log.retry_count)
        logger.info(f"ä»»åŠ¡ {task_log.id} å°†åœ¨ {retry_interval} ç§’åé‡è¯•")
        
        # 3. ç­‰å¾…é‡è¯•é—´éš”
        await asyncio.sleep(retry_interval)
        
        # 4. åˆ›å»ºé‡è¯•ä»»åŠ¡
        retry_task_log = TaskLog(
            task_name=f"{task_log.task_name} (é‡è¯• {task_log.retry_count + 1})",
            script_id=task_log.script_id,
            device_id=task_log.device_id,
            status="pending",
            retry_count=task_log.retry_count + 1,
            max_retry=task_log.max_retry,
            retry_enabled=task_log.retry_enabled,
            retry_interval=task_log.retry_interval,
            parent_task_id=task_log.id,
            is_retry=True,
            retry_reason=failure_type
        )
        
        self.db.add(retry_task_log)
        self.db.commit()
        self.db.refresh(retry_task_log)
        
        # 5. è®°å½•é‡è¯•å†å²
        retry_history = RetryHistory(
            task_log_id=task_log.id,
            retry_number=task_log.retry_count + 1,
            retry_reason=failure_type
        )
        self.db.add(retry_history)
        self.db.commit()
        
        logger.info(f"åˆ›å»ºé‡è¯•ä»»åŠ¡ {retry_task_log.id}, åŸä»»åŠ¡ {task_log.id}")
        
        # 6. æ‰§è¡Œé‡è¯•ä»»åŠ¡
        from app.services.task_executor import TaskExecutor
        executor = TaskExecutor()
        
        # è·å–è„šæœ¬æ­¥éª¤
        from app.models.script import Script
        script = self.db.get(Script, task_log.script_id)
        steps = []
        if script and script.steps_json:
            import json
            try:
                steps = json.loads(script.steps_json)
            except:
                steps = []
        
        # æ‰§è¡Œä»»åŠ¡
        result = await executor.execute_script(
            task_id=retry_task_log.id,
            script_id=task_log.script_id,
            device_id=task_log.device_id,
            steps=steps
        )
        
        # 7. æ›´æ–°é‡è¯•å†å²
        retry_history.result = result["status"]
        if result["status"] == "failed":
            retry_history.error_message = result.get("message", "")
        self.db.add(retry_history)
        self.db.commit()
        
        # 8. å¦‚æœé‡è¯•ä»ç„¶å¤±è´¥ï¼Œç»§ç»­é‡è¯•
        if result["status"] == "failed" and retry_task_log.retry_count < retry_task_log.max_retry:
            # è·å–å¤±è´¥åˆ†æ
            statement = select(FailureAnalysis).where(
                FailureAnalysis.task_log_id == retry_task_log.id
            )
            failure_analysis = self.db.exec(statement).first()
            
            if failure_analysis:
                await self.retry_task(retry_task_log, failure_analysis.failure_type)
        
        return retry_task_log
```

### 3.3 é›†æˆåˆ°ä»»åŠ¡æ‰§è¡Œæµç¨‹

```python
# backend/app/api/tasks.py

async def execute_task_background(
    task_log_id: int,
    script_id: int,
    device_id: int,
    steps: list
):
    """åå°æ‰§è¡Œä»»åŠ¡"""
    from app.core.database import engine
    from app.services.failure_service import FailureService
    from app.services.retry_service import RetryService
    
    executor = TaskExecutor()
    
    try:
        # æ‰§è¡Œè„šæœ¬
        result = await executor.execute_script(
            task_id=task_log_id,
            script_id=script_id,
            device_id=device_id,
            steps=steps
        )
        
        # æ›´æ–°ä»»åŠ¡æ—¥å¿—
        with Session(engine) as db:
            task_log = db.get(TaskLog, task_log_id)
            if task_log:
                task_log.status = result["status"]
                task_log.end_time = datetime.now()
                if result["status"] == "failed":
                    task_log.error_message = result.get("message", "æ‰§è¡Œå¤±è´¥")
                
                # è®¡ç®—æ‰§è¡Œæ—¶é•¿
                if task_log.start_time and task_log.end_time:
                    duration = (task_log.end_time - task_log.start_time).total_seconds()
                    task_log.duration = int(duration)
                
                db.add(task_log)
                db.commit()
                
                # å¦‚æœå¤±è´¥ï¼Œè‡ªåŠ¨åˆ†æ
                if result["status"] == "failed":
                    print(f"ğŸ” å¼€å§‹åˆ†æå¤±è´¥åŸå› ...")
                    failure_service = FailureService(db)
                    failure_analysis = await failure_service.analyze_task_failure(task_log_id)
                    
                    # ğŸ†• æ™ºèƒ½é‡è¯•
                    if failure_analysis:
                        print(f"ğŸ”„ æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯•...")
                        retry_service = RetryService(db)
                        await retry_service.retry_task(task_log, failure_analysis.failure_type)
                
                # æ¢å¤è®¾å¤‡çŠ¶æ€
                device = db.get(Device, device_id)
                if device:
                    device.status = "online"
                    db.add(device)
                    db.commit()
                
                print(f"âœ… ä»»åŠ¡å®Œæˆ: {task_log_id}, çŠ¶æ€: {result['status']}")
    
    except Exception as e:
        print(f"âŒ ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸: {task_log_id}, é”™è¯¯: {e}")
        # ... å¼‚å¸¸å¤„ç†
```

### 3.4 APIæ¥å£

```python
# backend/app/api/retry.py

from fastapi import APIRouter, Depends, HTTPException
from sqlmodel import Session, select
from app.core.database import get_session
from app.models.retry_config import RetryConfig, RetryHistory
from app.schemas.common import Response
from pydantic import BaseModel

router = APIRouter(prefix="/retry", tags=["é‡è¯•ç®¡ç†"])

class RetryConfigUpdate(BaseModel):
    """é‡è¯•é…ç½®æ›´æ–°"""
    enabled: bool
    max_retry: int
    retry_interval: int
    retry_on_timeout: bool
    retry_on_network_error: bool
    retry_on_element_not_found: bool
    retry_on_device_disconnected: bool
    retry_on_app_crash: bool
    retry_on_permission_denied: bool
    retry_on_script_error: bool
    exponential_backoff: bool
    max_retry_interval: int

@router.get("/config", response_model=Response[RetryConfig])
async def get_retry_config(db: Session = Depends(get_session)):
    """è·å–é‡è¯•é…ç½®"""
    statement = select(RetryConfig).limit(1)
    config = db.exec(statement).first()
    
    if not config:
        config = RetryConfig()
        db.add(config)
        db.commit()
        db.refresh(config)
    
    return Response(data=config)

@router.put("/config", response_model=Response[RetryConfig])
async def update_retry_config(
    config_data: RetryConfigUpdate,
    db: Session = Depends(get_session)
):
    """æ›´æ–°é‡è¯•é…ç½®"""
    statement = select(RetryConfig).limit(1)
    config = db.exec(statement).first()
    
    if not config:
        config = RetryConfig()
    
    # æ›´æ–°å­—æ®µ
    for key, value in config_data.model_dump().items():
        setattr(config, key, value)
    
    config.updated_at = datetime.now()
    db.add(config)
    db.commit()
    db.refresh(config)
    
    return Response(message="é‡è¯•é…ç½®æ›´æ–°æˆåŠŸ", data=config)

@router.get("/history/{task_log_id}", response_model=Response[list])
async def get_retry_history(
    task_log_id: int,
    db: Session = Depends(get_session)
):
    """è·å–ä»»åŠ¡é‡è¯•å†å²"""
    statement = select(RetryHistory).where(
        RetryHistory.task_log_id == task_log_id
    ).order_by(RetryHistory.retry_time)
    
    histories = db.exec(statement).all()
    
    return Response(data=[
        {
            "retry_number": h.retry_number,
            "retry_reason": h.retry_reason,
            "retry_time": h.retry_time.isoformat(),
            "result": h.result,
            "error_message": h.error_message
        }
        for h in histories
    ])
```

### 3.5 å‰ç«¯é…ç½®ç•Œé¢

```typescript
// src/pages/RetrySettings.tsx

import { Card, Form, Switch, InputNumber, Button, message, Divider } from 'antd'
import { useState, useEffect } from 'react'

const RetrySettings = () => {
  const [form] = Form.useForm()
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    loadConfig()
  }, [])

  const loadConfig = async () => {
    try {
      const response = await fetch('/api/v1/retry/config')
      const result = await response.json()
      form.setFieldsValue(result.data)
    } catch (error) {
      message.error('åŠ è½½é…ç½®å¤±è´¥')
    }
  }

  const handleSave = async (values: any) => {
    setLoading(true)
    try {
      await fetch('/api/v1/retry/config', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(values)
      })
      message.success('é…ç½®ä¿å­˜æˆåŠŸ')
    } catch (error) {
      message.error('ä¿å­˜å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  return (
    <Card title="æ™ºèƒ½é‡è¯•é…ç½®">
      <Form
        form={form}
        layout="vertical"
        onFinish={handleSave}
      >
        <Form.Item
          label="å¯ç”¨é‡è¯•"
          name="enabled"
          valuePropName="checked"
        >
          <Switch />
        </Form.Item>

        <Form.Item
          label="æœ€å¤§é‡è¯•æ¬¡æ•°"
          name="max_retry"
          rules={[{ required: true }]}
        >
          <InputNumber min={1} max={10} />
        </Form.Item>

        <Form.Item
          label="é‡è¯•é—´éš”ï¼ˆç§’ï¼‰"
          name="retry_interval"
          rules={[{ required: true }]}
        >
          <InputNumber min={1} max={300} />
        </Form.Item>

        <Divider>é‡è¯•ç­–ç•¥</Divider>

        <Form.Item
          label="è¶…æ—¶æ—¶é‡è¯•"
          name="retry_on_timeout"
          valuePropName="checked"
        >
          <Switch />
        </Form.Item>

        <Form.Item
          label="ç½‘ç»œé”™è¯¯æ—¶é‡è¯•"
          name="retry_on_network_error"
          valuePropName="checked"
        >
          <Switch />
        </Form.Item>

        <Form.Item
          label="å…ƒç´ æœªæ‰¾åˆ°æ—¶é‡è¯•"
          name="retry_on_element_not_found"
          valuePropName="checked"
        >
          <Switch />
        </Form.Item>

        <Divider>é«˜çº§é…ç½®</Divider>

        <Form.Item
          label="æŒ‡æ•°é€€é¿"
          name="exponential_backoff"
          valuePropName="checked"
          tooltip="é‡è¯•é—´éš”é€’å¢ï¼š5s, 10s, 20s, 40s..."
        >
          <Switch />
        </Form.Item>

        <Form.Item
          label="æœ€å¤§é‡è¯•é—´éš”ï¼ˆç§’ï¼‰"
          name="max_retry_interval"
        >
          <InputNumber min={10} max={600} />
        </Form.Item>

        <Form.Item>
          <Button type="primary" htmlType="submit" loading={loading}>
            ä¿å­˜é…ç½®
          </Button>
        </Form.Item>
      </Form>
    </Card>
  )
}

export default RetrySettings
```

## ğŸ“ˆ é‡è¯•æ•ˆæœç¤ºä¾‹

### åœºæ™¯1: ç½‘ç»œæŠ–åŠ¨

```
åŸä»»åŠ¡: å¤±è´¥ (network_error)
  â†“ ç­‰å¾… 5ç§’
é‡è¯•1: å¤±è´¥ (network_error)
  â†“ ç­‰å¾… 10ç§’ (æŒ‡æ•°é€€é¿)
é‡è¯•2: æˆåŠŸ âœ…

ç»“æœ: ä»»åŠ¡æœ€ç»ˆæˆåŠŸï¼Œé¿å…è¯¯æŠ¥
```

### åœºæ™¯2: å…ƒç´ åŠ è½½æ…¢

```
åŸä»»åŠ¡: å¤±è´¥ (element_not_found)
  â†“ ç­‰å¾… 5ç§’
é‡è¯•1: æˆåŠŸ âœ…

ç»“æœ: é¡µé¢åŠ è½½å®Œæˆï¼Œå…ƒç´ æ‰¾åˆ°
```

### åœºæ™¯3: è®¾å¤‡æ–­å¼€ï¼ˆä¸é‡è¯•ï¼‰

```
åŸä»»åŠ¡: å¤±è´¥ (device_disconnected)
  â†“ ä¸é‡è¯• âŒ

ç»“æœ: ç›´æ¥æ ‡è®°å¤±è´¥ï¼Œé¿å…æ— æ•ˆé‡è¯•
```

## âœ… æµ‹è¯•ç”¨ä¾‹

```python
# tests/test_retry.py

def test_should_retry_on_timeout(db):
    """æµ‹è¯•è¶…æ—¶æ—¶åº”è¯¥é‡è¯•"""
    service = RetryService(db)
    task_log = TaskLog(retry_count=0, max_retry=3, retry_enabled=True)
    
    assert service.should_retry(task_log, "timeout") == True

def test_should_not_retry_on_device_disconnected(db):
    """æµ‹è¯•è®¾å¤‡æ–­å¼€æ—¶ä¸åº”è¯¥é‡è¯•"""
    service = RetryService(db)
    task_log = TaskLog(retry_count=0, max_retry=3, retry_enabled=True)
    
    assert service.should_retry(task_log, "device_disconnected") == False

def test_exponential_backoff(db):
    """æµ‹è¯•æŒ‡æ•°é€€é¿"""
    service = RetryService(db)
    
    assert service.calculate_retry_interval(0) == 5
    assert service.calculate_retry_interval(1) == 10
    assert service.calculate_retry_interval(2) == 20
    assert service.calculate_retry_interval(3) == 40
```

## ğŸ“Š é¢„æœŸæ•ˆæœ

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡ |
|------|--------|--------|------|
| æˆåŠŸç‡ | 70% | 90%+ | +20% |
| è¯¯æŠ¥ç‡ | 30% | 10% | -20% |
| äººå·¥é‡è¯•æ¬¡æ•° | 50æ¬¡/å¤© | 5æ¬¡/å¤© | -90% |
| èŠ‚çœæ—¶é—´ | 0 | 2-3å°æ—¶/å¤© | - |

## ğŸ¯ å®æ–½å»ºè®®

1. **ç¬¬1å¤©**: å®ç°åŸºç¡€é‡è¯•åŠŸèƒ½
2. **ç¬¬2å¤©**: å®ç°æ™ºèƒ½é‡è¯•ç­–ç•¥
3. **ç¬¬3å¤©**: æ·»åŠ é…ç½®ç•Œé¢å’Œæµ‹è¯•
4. **ç¬¬4å¤©**: ç°åº¦æµ‹è¯•å’Œä¼˜åŒ–

æ€»å·¥æ—¶: çº¦13å°æ—¶ï¼ˆ2ä¸ªå·¥ä½œæ—¥ï¼‰
