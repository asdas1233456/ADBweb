# 2. è„šæœ¬æ‰§è¡Œå†å²å¯¹æ¯”

## ğŸ“Œ åŠŸèƒ½æ¦‚è¿°

**ç°çŠ¶**: åªèƒ½æŸ¥çœ‹å•æ¬¡æ‰§è¡Œç»“æœ  
**ç›®æ ‡**: æä¾›è„šæœ¬æ‰§è¡Œå†å²åˆ†æå’Œå¯¹æ¯”èƒ½åŠ›

## ğŸ¯ ä¸šåŠ¡ä»·å€¼

- å¿«é€Ÿè¯†åˆ«è„šæœ¬ç¨³å®šæ€§é—®é¢˜ï¼ˆæˆåŠŸç‡æ³¢åŠ¨ï¼‰
- å‘ç°æ€§èƒ½é€€åŒ–ï¼ˆæ‰§è¡Œæ—¶é•¿å¢åŠ ï¼‰
- å®šä½é«˜é¢‘å¤±è´¥æ­¥éª¤ï¼ˆä¼˜åŒ–é‡ç‚¹ï¼‰

## ğŸ“Š åŠŸèƒ½åˆ—è¡¨

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | å®ç°éš¾åº¦ | é¢„è®¡å·¥æ—¶ |
|------|--------|---------|---------|
| æ‰§è¡Œç»“æœå¯¹æ¯” | P0 | ç®€å• | 3å°æ—¶ |
| æ€§èƒ½è¶‹åŠ¿å›¾ | P0 | ä¸­ç­‰ | 4å°æ—¶ |
| å¤±è´¥æ­¥éª¤çƒ­åŠ›å›¾ | P1 | ä¸­ç­‰ | 5å°æ—¶ |
| æˆåŠŸç‡è¶‹åŠ¿ | P0 | ç®€å• | 2å°æ—¶ |

## ğŸ”§ æŠ€æœ¯å®ç°æ–¹æ¡ˆ

### 2.1 æ•°æ®æ¨¡å‹è®¾è®¡

**æ–°å¢è¡¨: script_execution_stats**

```python
# backend/app/models/script_stats.py

from sqlmodel import SQLModel, Field
from datetime import datetime, date
from typing import Optional

class ScriptExecutionStats(SQLModel, table=True):
    """è„šæœ¬æ‰§è¡Œç»Ÿè®¡"""
    __tablename__ = "script_execution_stats"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    script_id: int = Field(foreign_key="scripts.id", index=True)
    
    # ç»Ÿè®¡æ•°æ®
    total_executions: int = 0
    success_count: int = 0
    failed_count: int = 0
    success_rate: float = 0.0
    
    # æ€§èƒ½æ•°æ®
    avg_duration: float = 0.0  # å¹³å‡æ‰§è¡Œæ—¶é•¿ï¼ˆç§’ï¼‰
    min_duration: float = 0.0
    max_duration: float = 0.0
    
    # æ—¶é—´èŒƒå›´
    stat_date: date = Field(default_factory=date.today, index=True)
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)


class StepFailureStats(SQLModel, table=True):
    """æ­¥éª¤å¤±è´¥ç»Ÿè®¡"""
    __tablename__ = "step_failure_stats"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    script_id: int = Field(foreign_key="scripts.id", index=True)
    step_index: int  # æ­¥éª¤ç´¢å¼•
    step_name: str  # æ­¥éª¤åç§°
    
    # å¤±è´¥ç»Ÿè®¡
    failure_count: int = 0
    total_count: int = 0
    failure_rate: float = 0.0
    
    # æœ€è¿‘å¤±è´¥ä¿¡æ¯
    last_failure_time: Optional[datetime] = None
    last_error_message: Optional[str] = None
    
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
```

### 2.2 ç»Ÿè®¡æ•°æ®æ”¶é›†æœåŠ¡

```python
# backend/app/services/stats_service.py

from sqlmodel import Session, select
from datetime import date, datetime, timedelta
from app.models.script_stats import ScriptExecutionStats, StepFailureStats
from app.models.task_log import TaskLog

class StatsService:
    def __init__(self, db: Session):
        self.db = db
    
    async def update_script_stats(self, task_log: TaskLog):
        """æ›´æ–°è„šæœ¬ç»Ÿè®¡æ•°æ®"""
        today = date.today()
        
        # è·å–æˆ–åˆ›å»ºä»Šæ—¥ç»Ÿè®¡
        statement = select(ScriptExecutionStats).where(
            ScriptExecutionStats.script_id == task_log.script_id,
            ScriptExecutionStats.stat_date == today
        )
        stats = self.db.exec(statement).first()
        
        if not stats:
            stats = ScriptExecutionStats(
                script_id=task_log.script_id,
                stat_date=today
            )
        
        # æ›´æ–°ç»Ÿè®¡
        stats.total_executions += 1
        if task_log.status == "success":
            stats.success_count += 1
        elif task_log.status == "failed":
            stats.failed_count += 1
        
        # è®¡ç®—æˆåŠŸç‡
        if stats.total_executions > 0:
            stats.success_rate = (stats.success_count / stats.total_executions) * 100
        
        # æ›´æ–°æ‰§è¡Œæ—¶é•¿
        if task_log.duration:
            if stats.total_executions == 1:
                stats.avg_duration = task_log.duration
                stats.min_duration = task_log.duration
                stats.max_duration = task_log.duration
            else:
                # è®¡ç®—æ–°çš„å¹³å‡å€¼
                total_duration = stats.avg_duration * (stats.total_executions - 1) + task_log.duration
                stats.avg_duration = total_duration / stats.total_executions
                stats.min_duration = min(stats.min_duration, task_log.duration)
                stats.max_duration = max(stats.max_duration, task_log.duration)
        
        stats.updated_at = datetime.now()
        self.db.add(stats)
        self.db.commit()
        
        return stats
    
    async def update_step_failure_stats(
        self, 
        task_log: TaskLog, 
        failed_step_index: int, 
        failed_step_name: str, 
        error_message: str
    ):
        """æ›´æ–°æ­¥éª¤å¤±è´¥ç»Ÿè®¡"""
        statement = select(StepFailureStats).where(
            StepFailureStats.script_id == task_log.script_id,
            StepFailureStats.step_index == failed_step_index
        )
        stats = self.db.exec(statement).first()
        
        if not stats:
            stats = StepFailureStats(
                script_id=task_log.script_id,
                step_index=failed_step_index,
                step_name=failed_step_name
            )
        
        stats.total_count += 1
        if task_log.status == "failed":
            stats.failure_count += 1
            stats.last_failure_time = datetime.now()
            stats.last_error_message = error_message
        
        if stats.total_count > 0:
            stats.failure_rate = (stats.failure_count / stats.total_count) * 100
        
        stats.updated_at = datetime.now()
        self.db.add(stats)
        self.db.commit()
        
        return stats
```

è¯¦ç»†å®ç°è¯·æŸ¥çœ‹å®Œæ•´æ–‡æ¡£...
