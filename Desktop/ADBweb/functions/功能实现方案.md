# ğŸš€ ADBè‡ªåŠ¨åŒ–æµ‹è¯•å¹³å° - åŠŸèƒ½å®ç°æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•

- [1. è®¾å¤‡æ‰¹é‡æ“ä½œå¢å¼º](#1-è®¾å¤‡æ‰¹é‡æ“ä½œå¢å¼º)
- [2. è„šæœ¬æ‰§è¡Œå†å²å¯¹æ¯”](#2-è„šæœ¬æ‰§è¡Œå†å²å¯¹æ¯”)
- [3. æ™ºèƒ½é‡è¯•æœºåˆ¶](#3-æ™ºèƒ½é‡è¯•æœºåˆ¶)

---

## 1. è®¾å¤‡æ‰¹é‡æ“ä½œå¢å¼º

### ğŸ“Œ åŠŸèƒ½æ¦‚è¿°

**ç°çŠ¶**: åªæœ‰æ‰¹é‡æ‰§è¡Œè„šæœ¬åŠŸèƒ½  
**ç›®æ ‡**: æä¾›å®Œæ•´çš„è®¾å¤‡æ‰¹é‡ç®¡ç†èƒ½åŠ›

### ğŸ¯ ä¸šåŠ¡ä»·å€¼

- å¤§å¹…æå‡å¤šè®¾å¤‡ç®¡ç†æ•ˆç‡ï¼ˆèŠ‚çœ80%æ“ä½œæ—¶é—´ï¼‰
- ç‰¹åˆ«é€‚ç”¨äºå›å½’æµ‹è¯•åœºæ™¯ï¼ˆä¸€é”®æ“ä½œæ‰€æœ‰è®¾å¤‡ï¼‰
- å‡å°‘äººå·¥é‡å¤æ“ä½œï¼Œé™ä½å‡ºé”™ç‡

### ğŸ“Š åŠŸèƒ½åˆ—è¡¨

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | å®ç°éš¾åº¦ | é¢„è®¡å·¥æ—¶ |
|------|--------|---------|---------|
| æ‰¹é‡é‡å¯è®¾å¤‡ | P0 | ç®€å• | 2å°æ—¶ |
| æ‰¹é‡æ¸…ç†ç¼“å­˜ | P0 | ç®€å• | 2å°æ—¶ |
| æ‰¹é‡å®‰è£…åº”ç”¨ | P1 | ä¸­ç­‰ | 4å°æ—¶ |
| æ‰¹é‡å¸è½½åº”ç”¨ | P1 | ç®€å• | 2å°æ—¶ |
| æ‰¹é‡æˆªå›¾å¯¹æ¯” | P2 | å¤æ‚ | 8å°æ—¶ |

### ğŸ”§ æŠ€æœ¯å®ç°æ–¹æ¡ˆ

#### 1.1 æ‰¹é‡é‡å¯è®¾å¤‡

**ADBå‘½ä»¤**:
```bash
adb -s <device_serial> reboot
```

**å®ç°æ­¥éª¤**:


1. **åç«¯APIè®¾è®¡** (`backend/app/api/devices.py`)

```python
@router.post("/batch/reboot", response_model=Response[dict])
async def batch_reboot_devices(
    device_ids: list[int],
    db: Session = Depends(get_session)
):
    """æ‰¹é‡é‡å¯è®¾å¤‡"""
    results = {"success": [], "failed": []}
    
    for device_id in device_ids:
        device = db.get(Device, device_id)
        if not device:
            results["failed"].append({"id": device_id, "reason": "è®¾å¤‡ä¸å­˜åœ¨"})
            continue
        
        try:
            # æ‰§è¡ŒADBé‡å¯å‘½ä»¤
            subprocess.run(
                ["adb", "-s", device.serial_number, "reboot"],
                check=True,
                timeout=10
            )
            results["success"].append(device_id)
            
            # è®°å½•æ´»åŠ¨æ—¥å¿—
            activity = ActivityLog(
                activity_type="device_reboot",
                description=f"é‡å¯è®¾å¤‡: {device.model}",
                related_id=device.id,
                related_type="device",
                status="success"
            )
            db.add(activity)
        except Exception as e:
            results["failed"].append({"id": device_id, "reason": str(e)})
    
    db.commit()
    return Response(
        message=f"æˆåŠŸé‡å¯ {len(results['success'])} å°è®¾å¤‡",
        data=results
    )
```

2. **å‰ç«¯UIå®ç°** (`src/pages/DeviceManagement.tsx`)

```typescript
// æ·»åŠ æ‰¹é‡æ“ä½œæŒ‰é’®
const [selectedRowKeys, setSelectedRowKeys] = useState<number[]>([])

const rowSelection = {
  selectedRowKeys,
  onChange: (keys: React.Key[]) => {
    setSelectedRowKeys(keys as number[])
  },
}

const handleBatchReboot = async () => {
  if (selectedRowKeys.length === 0) {
    message.warning('è¯·å…ˆé€‰æ‹©è®¾å¤‡')
    return
  }
  
  Modal.confirm({
    title: 'ç¡®è®¤é‡å¯',
    content: `ç¡®å®šè¦é‡å¯é€‰ä¸­çš„ ${selectedRowKeys.length} å°è®¾å¤‡å—ï¼Ÿ`,
    onOk: async () => {
      try {
        const result = await deviceApi.batchReboot(selectedRowKeys)
        message.success(`æˆåŠŸé‡å¯ ${result.success.length} å°è®¾å¤‡`)
        loadDevices()
      } catch (error) {
        message.error('æ‰¹é‡é‡å¯å¤±è´¥')
      }
    }
  })
}

// åœ¨è¡¨æ ¼ä¸Šæ–¹æ·»åŠ æ‰¹é‡æ“ä½œæŒ‰é’®
<Space>
  <Button 
    disabled={selectedRowKeys.length === 0}
    onClick={handleBatchReboot}
  >
    æ‰¹é‡é‡å¯
  </Button>
</Space>

<Table
  rowSelection={rowSelection}
  // ... å…¶ä»–é…ç½®
/>
```

#### 1.2 æ‰¹é‡æ¸…ç†ç¼“å­˜

**ADBå‘½ä»¤**:
```bash
# æ¸…ç†åº”ç”¨ç¼“å­˜
adb -s <device_serial> shell pm clear <package_name>

# æ¸…ç†æ‰€æœ‰åº”ç”¨ç¼“å­˜
adb -s <device_serial> shell pm list packages | cut -f 2 -d ":" | xargs -n1 adb shell pm clear
```

**å®ç°æ­¥éª¤**:

1. **åç«¯æœåŠ¡** (`backend/app/services/device_service.py`)

```python
class DeviceService:
    @staticmethod
    async def clear_cache(device_serial: str, package_name: Optional[str] = None):
        """æ¸…ç†è®¾å¤‡ç¼“å­˜"""
        try:
            if package_name:
                # æ¸…ç†æŒ‡å®šåº”ç”¨ç¼“å­˜
                cmd = ["adb", "-s", device_serial, "shell", "pm", "clear", package_name]
            else:
                # æ¸…ç†æ‰€æœ‰åº”ç”¨ç¼“å­˜ï¼ˆæ…ç”¨ï¼‰
                cmd = ["adb", "-s", device_serial, "shell", "pm", "trim-caches", "999G"]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            return result.returncode == 0
        except Exception as e:
            logger.error(f"æ¸…ç†ç¼“å­˜å¤±è´¥: {e}")
            return False
```

2. **APIæ¥å£**

```python
class ClearCacheRequest(BaseModel):
    device_ids: list[int]
    package_name: Optional[str] = None  # ä¸ºç©ºåˆ™æ¸…ç†æ‰€æœ‰

@router.post("/batch/clear-cache", response_model=Response[dict])
async def batch_clear_cache(
    request: ClearCacheRequest,
    db: Session = Depends(get_session)
):
    """æ‰¹é‡æ¸…ç†ç¼“å­˜"""
    results = {"success": [], "failed": []}
    
    for device_id in request.device_ids:
        device = db.get(Device, device_id)
        if not device:
            results["failed"].append({"id": device_id, "reason": "è®¾å¤‡ä¸å­˜åœ¨"})
            continue
        
        success = await DeviceService.clear_cache(
            device.serial_number, 
            request.package_name
        )
        
        if success:
            results["success"].append(device_id)
        else:
            results["failed"].append({"id": device_id, "reason": "æ¸…ç†å¤±è´¥"})
    
    return Response(
        message=f"æˆåŠŸæ¸…ç† {len(results['success'])} å°è®¾å¤‡",
        data=results
    )
```

#### 1.3 æ‰¹é‡å®‰è£…/å¸è½½åº”ç”¨

**ADBå‘½ä»¤**:
```bash
# å®‰è£…åº”ç”¨
adb -s <device_serial> install -r <apk_path>

# å¸è½½åº”ç”¨
adb -s <device_serial> uninstall <package_name>
```

**å®ç°æ­¥éª¤**:

1. **æ–‡ä»¶ä¸Šä¼ æ¥å£** (`backend/app/api/upload.py`)

```python
@router.post("/apk", response_model=Response[dict])
async def upload_apk(file: UploadFile = File(...)):
    """ä¸Šä¼ APKæ–‡ä»¶"""
    # ä¿å­˜APKæ–‡ä»¶
    apk_dir = Path("uploads/apks")
    apk_dir.mkdir(parents=True, exist_ok=True)
    
    file_path = apk_dir / file.filename
    with open(file_path, "wb") as f:
        content = await file.read()
        f.write(content)
    
    return Response(
        message="APKä¸Šä¼ æˆåŠŸ",
        data={"file_path": str(file_path), "filename": file.filename}
    )
```

2. **æ‰¹é‡å®‰è£…æ¥å£**

```python
class InstallAppRequest(BaseModel):
    device_ids: list[int]
    apk_path: str

@router.post("/batch/install-app", response_model=Response[dict])
async def batch_install_app(
    request: InstallAppRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_session)
):
    """æ‰¹é‡å®‰è£…åº”ç”¨"""
    # éªŒè¯APKæ–‡ä»¶å­˜åœ¨
    if not Path(request.apk_path).exists():
        raise HTTPException(status_code=404, detail="APKæ–‡ä»¶ä¸å­˜åœ¨")
    
    # åå°å¼‚æ­¥å®‰è£…
    background_tasks.add_task(
        install_app_background,
        request.device_ids,
        request.apk_path,
        db
    )
    
    return Response(
        message=f"å¼€å§‹å‘ {len(request.device_ids)} å°è®¾å¤‡å®‰è£…åº”ç”¨",
        data={"status": "processing"}
    )

async def install_app_background(device_ids: list[int], apk_path: str, db: Session):
    """åå°å®‰è£…åº”ç”¨"""
    for device_id in device_ids:
        device = db.get(Device, device_id)
        if not device:
            continue
        
        try:
            subprocess.run(
                ["adb", "-s", device.serial_number, "install", "-r", apk_path],
                check=True,
                timeout=60
            )
            logger.info(f"è®¾å¤‡ {device.model} å®‰è£…æˆåŠŸ")
        except Exception as e:
            logger.error(f"è®¾å¤‡ {device.model} å®‰è£…å¤±è´¥: {e}")
```

#### 1.4 æ‰¹é‡æˆªå›¾å¯¹æ¯”

**å®ç°æ€è·¯**:
1. æ‰¹é‡æˆªå›¾æ‰€æœ‰è®¾å¤‡
2. ä½¿ç”¨å›¾åƒå¯¹æ¯”ç®—æ³•ï¼ˆSSIM/MSEï¼‰
3. ç”Ÿæˆå¯¹æ¯”æŠ¥å‘Š

**æ ¸å¿ƒä»£ç **:

```python
from PIL import Image
import numpy as np
from skimage.metrics import structural_similarity as ssim

class ScreenshotService:
    @staticmethod
    async def capture_screenshot(device_serial: str) -> str:
        """æˆªå›¾å¹¶ä¿å­˜"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{device_serial}_{timestamp}.png"
        filepath = Path(f"uploads/screenshots/{filename}")
        
        # ADBæˆªå›¾
        subprocess.run([
            "adb", "-s", device_serial, "exec-out", "screencap", "-p"
        ], stdout=open(filepath, "wb"), check=True)
        
        return str(filepath)
    
    @staticmethod
    def compare_images(img1_path: str, img2_path: str) -> dict:
        """å¯¹æ¯”ä¸¤å¼ å›¾ç‰‡"""
        img1 = Image.open(img1_path).convert('L')
        img2 = Image.open(img2_path).convert('L')
        
        # è°ƒæ•´ä¸ºç›¸åŒå°ºå¯¸
        img2 = img2.resize(img1.size)
        
        # è½¬ä¸ºnumpyæ•°ç»„
        arr1 = np.array(img1)
        arr2 = np.array(img2)
        
        # è®¡ç®—ç›¸ä¼¼åº¦
        similarity = ssim(arr1, arr2)
        
        return {
            "similarity": float(similarity),
            "is_similar": similarity > 0.95,  # 95%ä»¥ä¸Šè®¤ä¸ºç›¸ä¼¼
            "difference": 1 - similarity
        }

@router.post("/batch/screenshot-compare", response_model=Response[dict])
async def batch_screenshot_compare(
    device_ids: list[int],
    baseline_device_id: int,  # åŸºå‡†è®¾å¤‡
    db: Session = Depends(get_session)
):
    """æ‰¹é‡æˆªå›¾å¯¹æ¯”"""
    # 1. æˆªå–åŸºå‡†è®¾å¤‡æˆªå›¾
    baseline_device = db.get(Device, baseline_device_id)
    baseline_screenshot = await ScreenshotService.capture_screenshot(
        baseline_device.serial_number
    )
    
    # 2. æˆªå–å…¶ä»–è®¾å¤‡å¹¶å¯¹æ¯”
    results = []
    for device_id in device_ids:
        if device_id == baseline_device_id:
            continue
        
        device = db.get(Device, device_id)
        screenshot = await ScreenshotService.capture_screenshot(
            device.serial_number
        )
        
        # å¯¹æ¯”
        comparison = ScreenshotService.compare_images(
            baseline_screenshot, 
            screenshot
        )
        
        results.append({
            "device_id": device_id,
            "device_name": device.model,
            "screenshot": screenshot,
            **comparison
        })
    
    return Response(
        message="æˆªå›¾å¯¹æ¯”å®Œæˆ",
        data={
            "baseline": baseline_screenshot,
            "comparisons": results
        }
    )
```

### ğŸ“± å‰ç«¯UIè®¾è®¡

**æ‰¹é‡æ“ä½œé¢æ¿**:

```typescript
// æ‰¹é‡æ“ä½œä¸‹æ‹‰èœå•
const batchOperations = [
  { key: 'reboot', label: 'æ‰¹é‡é‡å¯', icon: <ReloadOutlined /> },
  { key: 'clear-cache', label: 'æ‰¹é‡æ¸…ç†ç¼“å­˜', icon: <ClearOutlined /> },
  { key: 'install', label: 'æ‰¹é‡å®‰è£…åº”ç”¨', icon: <DownloadOutlined /> },
  { key: 'uninstall', label: 'æ‰¹é‡å¸è½½åº”ç”¨', icon: <DeleteOutlined /> },
  { key: 'screenshot', label: 'æ‰¹é‡æˆªå›¾å¯¹æ¯”', icon: <CameraOutlined /> },
]

<Dropdown
  menu={{
    items: batchOperations,
    onClick: handleBatchOperation
  }}
  disabled={selectedRowKeys.length === 0}
>
  <Button>
    æ‰¹é‡æ“ä½œ <DownOutlined />
  </Button>
</Dropdown>
```

### âœ… æµ‹è¯•ç”¨ä¾‹

```python
# tests/test_batch_operations.py

def test_batch_reboot_devices(client, test_devices):
    """æµ‹è¯•æ‰¹é‡é‡å¯è®¾å¤‡"""
    device_ids = [d.id for d in test_devices[:3]]
    
    response = client.post("/api/v1/devices/batch/reboot", json={
        "device_ids": device_ids
    })
    
    assert response.status_code == 200
    data = response.json()["data"]
    assert len(data["success"]) == 3

def test_batch_clear_cache(client, test_devices):
    """æµ‹è¯•æ‰¹é‡æ¸…ç†ç¼“å­˜"""
    response = client.post("/api/v1/devices/batch/clear-cache", json={
        "device_ids": [1, 2],
        "package_name": "com.example.app"
    })
    
    assert response.status_code == 200
```

---


## 2. è„šæœ¬æ‰§è¡Œå†å²å¯¹æ¯”

### ğŸ“Œ åŠŸèƒ½æ¦‚è¿°

**ç°çŠ¶**: åªèƒ½æŸ¥çœ‹å•æ¬¡æ‰§è¡Œç»“æœ  
**ç›®æ ‡**: æä¾›è„šæœ¬æ‰§è¡Œå†å²åˆ†æå’Œå¯¹æ¯”èƒ½åŠ›

### ğŸ¯ ä¸šåŠ¡ä»·å€¼

- å¿«é€Ÿè¯†åˆ«è„šæœ¬ç¨³å®šæ€§é—®é¢˜ï¼ˆæˆåŠŸç‡æ³¢åŠ¨ï¼‰
- å‘ç°æ€§èƒ½é€€åŒ–ï¼ˆæ‰§è¡Œæ—¶é•¿å¢åŠ ï¼‰
- å®šä½é«˜é¢‘å¤±è´¥æ­¥éª¤ï¼ˆä¼˜åŒ–é‡ç‚¹ï¼‰

### ğŸ“Š åŠŸèƒ½åˆ—è¡¨

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | å®ç°éš¾åº¦ | é¢„è®¡å·¥æ—¶ |
|------|--------|---------|---------|
| æ‰§è¡Œç»“æœå¯¹æ¯” | P0 | ç®€å• | 3å°æ—¶ |
| æ€§èƒ½è¶‹åŠ¿å›¾ | P0 | ä¸­ç­‰ | 4å°æ—¶ |
| å¤±è´¥æ­¥éª¤çƒ­åŠ›å›¾ | P1 | ä¸­ç­‰ | 5å°æ—¶ |
| æˆåŠŸç‡è¶‹åŠ¿ | P0 | ç®€å• | 2å°æ—¶ |

### ğŸ”§ æŠ€æœ¯å®ç°æ–¹æ¡ˆ

#### 2.1 æ•°æ®æ¨¡å‹è®¾è®¡

**æ–°å¢è¡¨: script_execution_stats**

```python
# backend/app/models/script_stats.py

class ScriptExecutionStats(SQLModel, table=True):
    """è„šæœ¬æ‰§è¡Œç»Ÿè®¡"""
    __tablename__ = "script_execution_stats"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    script_id: int = Field(foreign_key="scripts.id", index=True)
    
    # ç»Ÿè®¡æ•°æ®
    total_executions: int = 0
    success_count: int = 0
    failed_count: int = 0
    success_rate: float = 0.0
    
    # æ€§èƒ½æ•°æ®
    avg_duration: float = 0.0  # å¹³å‡æ‰§è¡Œæ—¶é•¿ï¼ˆç§’ï¼‰
    min_duration: float = 0.0
    max_duration: float = 0.0
    
    # æ—¶é—´èŒƒå›´
    stat_date: date = Field(default_factory=date.today, index=True)
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)


class StepFailureStats(SQLModel, table=True):
    """æ­¥éª¤å¤±è´¥ç»Ÿè®¡"""
    __tablename__ = "step_failure_stats"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    script_id: int = Field(foreign_key="scripts.id", index=True)
    step_index: int  # æ­¥éª¤ç´¢å¼•
    step_name: str  # æ­¥éª¤åç§°
    
    # å¤±è´¥ç»Ÿè®¡
    failure_count: int = 0
    total_count: int = 0
    failure_rate: float = 0.0
    
    # æœ€è¿‘å¤±è´¥ä¿¡æ¯
    last_failure_time: Optional[datetime] = None
    last_error_message: Optional[str] = None
    
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
```

#### 2.2 ç»Ÿè®¡æ•°æ®æ”¶é›†

**ä»»åŠ¡å®Œæˆåè‡ªåŠ¨æ›´æ–°ç»Ÿè®¡**

```python
# backend/app/services/stats_service.onse.json()["data"]
    assert "trend" in data
    assert "summary" in data

def test_get_step_failure_heatmap(client, test_script):
    """æµ‹è¯•è·å–æ­¥éª¤å¤±è´¥çƒ­åŠ›å›¾"""
    response = client.get(f"/api/v1/script-stats/scripts/{test_script.id}/step-failures")
    
    assert response.status_code == 200
    data = response.json()["data"]
    assert "steps" in data
```

---

y(client, test_script):
    """æµ‹è¯•è·å–è„šæœ¬æ‰§è¡Œå†å²"""
    response = client.get(f"/api/v1/script-stats/scripts/{test_script.id}/history?days=7")
    
    assert response.status_code == 200
    data = response.json()["data"]
    assert "history" in data
    assert len(data["history"]) <= 7

def test_get_performance_trend(client, test_script):
    """æµ‹è¯•è·å–æ€§èƒ½è¶‹åŠ¿"""
    response = client.get(f"/api/v1/script-stats/scripts/{test_script.id}/performance-trend?days=30")
    
    assert response.status_code == 200
    data = resple: 'æ€»æ‰§è¡Œæ¬¡æ•°',
      dataIndex: 'total_count',
      key: 'total_count'
    },
    {
      title: 'æœ€è¿‘å¤±è´¥',
      dataIndex: 'last_failure_time',
      key: 'last_failure_time',
      render: (time) => time ? dayjs(time).fromNow() : '-'
    }
  ]

  return (
    <Card title="æ­¥éª¤å¤±è´¥åˆ†æ">
      <Table
        columns={columns}
        dataSource={data}
        rowKey="step_index"
        pagination={false}
      />
    </Card>
  )
}
```

### âœ… æµ‹è¯•ç”¨ä¾‹

```python
# tests/test_script_stats.py

def test_get_script_execution_histor    dataIndex: 'failure_rate',
      key: 'failure_rate',
      render: (rate) => (
        <Progress
          percent={rate}
          status={rate > 50 ? 'exception' : rate > 20 ? 'normal' : 'success'}
          format={(percent) => `${percent.toFixed(1)}%`}
        />
      ),
      sorter: (a, b) => a.failure_rate - b.failure_rate
    },
    {
      title: 'å¤±è´¥æ¬¡æ•°',
      dataIndex: 'failure_count',
      key: 'failure_count',
      sorter: (a, b) => a.failure_count - b.failure_count
    },
    {
      tit '@ant-design/icons'

const StepFailureHeatmap = ({ scriptId }) => {
  const [data, setData] = useState([])

  const columns = [
    {
      title: 'æ­¥éª¤',
      dataIndex: 'step_name',
      key: 'step_name',
      render: (text, record) => (
        <div>
          <div>{record.step_index + 1}. {text}</div>
          {record.failure_rate > 50 && (
            <Tag color="error" icon={<WarningOutlined />}>
              é«˜é¢‘å¤±è´¥
            </Tag>
          )}
        </div>
      )
    },
    {
      title: 'å¤±è´¥ç‡',
    const config = {
    data,
    xField: 'date',
    yField: 'value',
    seriesField: 'type',
    smooth: true,
    animation: {
      appear: {
        animation: 'path-in',
        duration: 1000,
      },
    },
  }

  return (
    <Card title="æ€§èƒ½è¶‹åŠ¿" loading={loading}>
      <Line {...config} />
    </Card>
  )
}

export default PerformanceTrendChart
```

**å¤±è´¥æ­¥éª¤çƒ­åŠ›å›¾**

```typescript
// src/components/StepFailureHeatmap.tsx

import { Card, Table, Progress, Tag } from 'antd'
import { WarningOutlined } fromesponse.json()
      
      // è½¬æ¢æ•°æ®æ ¼å¼
      const chartData = result.data.trend.dates.map((date: string, index: number) => [
        {
          date,
          type: 'å¹³å‡æ—¶é•¿',
          value: result.data.trend.avg_durations[index]
        },
        {
          date,
          type: 'æˆåŠŸç‡',
          value: result.data.trend.success_rates[index]
        }
      ]).flat()
      
      setData(chartData)
    } catch (error) {
      console.error('åŠ è½½è¶‹åŠ¿æ•°æ®å¤±è´¥:', error)
    } finally {
      setLoading(false)
    }
  }

tProps {
  scriptId: number
}

const PerformanceTrendChart = ({ scriptId }: PerformanceTrendChartProps) => {
  const [loading, setLoading] = useState(false)
  const [data, setData] = useState([])
  const [days, setDays] = useState(30)

  useEffect(() => {
    loadTrendData()
  }, [scriptId, days])

  const loadTrendData = async () => {
    setLoading(true)
    try {
      const response = await fetch(
        `/api/v1/script-stats/scripts/${scriptId}/performance-trend?days=${days}`
      )
      const result = await r e in executions if e["duration"]) / len(executions),
                "success_count": sum(1 for e in executions if e["status"] == "success"),
                "failed_count": sum(1 for e in executions if e["status"] == "failed")
            }
        }
    )
```

#### 2.4 å‰ç«¯å¯è§†åŒ–

**æ€§èƒ½è¶‹åŠ¿å›¾ç»„ä»¶**

```typescript
// src/components/PerformanceTrendChart.tsx

import { Line } from '@ant-design/charts'
import { Card, DatePicker, Spin } from 'antd'
import { useState, useEffect } from 'react'

interface PerformanceTrendCharog.id,
                "status": task_log.status,
                "duration": task_log.duration,
                "start_time": task_log.start_time.isoformat(),
                "end_time": task_log.end_time.isoformat() if task_log.end_time else None,
                "error_message": task_log.error_message
            })
    
    return Response(
        data={
            "script_id": script_id,
            "executions": executions,
            "comparison": {
                "avg_duration": sum(e["duration"] forrouter.get("/scripts/{script_id}/compare", response_model=Response[dict])
async def compare_executions(
    script_id: int,
    execution_ids: str = Query(..., description="é€—å·åˆ†éš”çš„æ‰§è¡ŒID"),
    db: Session = Depends(get_session)
):
    """å¯¹æ¯”å¤šæ¬¡æ‰§è¡Œç»“æœ"""
    ids = [int(id) for id in execution_ids.split(",")]
    
    executions = []
    for exec_id in ids:
        task_log = db.get(TaskLog, exec_id)
        if task_log and task_log.script_id == script_id:
            executions.append({
                "id": task_le": s.step_name,
                    "failure_count": s.failure_count,
                    "total_count": s.total_count,
                    "failure_rate": s.failure_rate,
                    "last_failure_time": s.last_failure_time.isoformat() if s.last_failure_time else None,
                    "last_error_message": s.last_error_message
                }
                for s in stats
            ],
            "most_failed_step": max(stats, key=lambda x: x.failure_count) if stats else None
        }
    )

@model=Response[dict])
async def get_step_failure_heatmap(
    script_id: int,
    db: Session = Depends(get_session)
):
    """è·å–æ­¥éª¤å¤±è´¥çƒ­åŠ›å›¾æ•°æ®"""
    statement = select(StepFailureStats).where(
        StepFailureStats.script_id == script_id
    ).order_by(StepFailureStats.step_index)
    
    stats = db.exec(statement).all()
    
    return Response(
        data={
            "script_id": script_id,
            "steps": [
                {
                    "step_index": s.step_index,
                    "step_nam                "max_durations": [s.max_duration for s in stats]
            },
            "summary": {
                "avg_duration": sum(durations) / len(durations) if durations else 0,
                "avg_success_rate": sum(success_rates) / len(success_rates) if success_rates else 0,
                "trend_direction": "improving" if len(success_rates) > 1 and success_rates[-1] > success_rates[0] else "declining"
            }
        }
    )

@router.get("/scripts/{script_id}/step-failures", response_riptExecutionStats.stat_date)
    
    stats = db.exec(statement).all()
    
    # è®¡ç®—è¶‹åŠ¿
    durations = [s.avg_duration for s in stats]
    success_rates = [s.success_rate for s in stats]
    
    return Response(
        data={
            "script_id": script_id,
            "trend": {
                "dates": [s.stat_date.isoformat() for s in stats],
                "avg_durations": durations,
                "success_rates": success_rates,
                "min_durations": [s.min_duration for s in stats],
           ]
        }
    )

@router.get("/scripts/{script_id}/performance-trend", response_model=Response[dict])
async def get_performance_trend(
    script_id: int,
    days: int = Query(default=30, description="æŸ¥è¯¢æœ€è¿‘Nå¤©"),
    db: Session = Depends(get_session)
):
    """è·å–æ€§èƒ½è¶‹åŠ¿"""
    start_date = date.today() - timedelta(days=days)
    
    statement = select(ScriptExecutionStats).where(
        ScriptExecutionStats.script_id == script_id,
        ScriptExecutionStats.stat_date >= start_date
    ).order_by(Sc       "history": [
                {
                    "date": s.stat_date.isoformat(),
                    "total_executions": s.total_executions,
                    "success_count": s.success_count,
                    "failed_count": s.failed_count,
                    "success_rate": s.success_rate,
                    "avg_duration": s.avg_duration,
                    "min_duration": s.min_duration,
                    "max_duration": s.max_duration
                }
                for s in stats
 ery(default=7, description="æŸ¥è¯¢æœ€è¿‘Nå¤©"),
    db: Session = Depends(get_session)
):
    """è·å–è„šæœ¬æ‰§è¡Œå†å²"""
    start_date = date.today() - timedelta(days=days)
    
    statement = select(ScriptExecutionStats).where(
        ScriptExecutionStats.script_id == script_id,
        ScriptExecutionStats.stat_date >= start_date
    ).order_by(ScriptExecutionStats.stat_date)
    
    stats = db.exec(statement).all()
    
    return Response(
        data={
            "script_id": script_id,
            "days": days,
     .status == "failed" and failed_step_index is not None:
        await stats_service.update_step_failure_stats(
            task_log, 
            failed_step_index, 
            failed_step_name, 
            error_message
        )
```

#### 2.3 APIæ¥å£è®¾è®¡

```python
# backend/app/api/script_stats.py

router = APIRouter(prefix="/script-stats", tags=["è„šæœ¬ç»Ÿè®¡"])

@router.get("/scripts/{script_id}/history", response_model=Response[dict])
async def get_script_execution_history(
    script_id: int,
    days: int = Qu       
        stats.failure_rate = (stats.failure_count / stats.total_count * 100) if stats.total_count > 0 else 0
        stats.updated_at = datetime.now()
        
        self.db.add(stats)
        self.db.commit()
```

**åœ¨ä»»åŠ¡æ‰§è¡Œå®Œæˆæ—¶è°ƒç”¨**

```python
# backend/app/api/tasks.py

async def execute_task_background(task_log_id: int, ...):
    """åå°æ‰§è¡Œä»»åŠ¡"""
    # ... æ‰§è¡Œä»»åŠ¡é€»è¾‘
    
    # æ›´æ–°ç»Ÿè®¡æ•°æ®
    stats_service = StatsService(db)
    await stats_service.update_script_stats(task_log)
    
    # å¦‚æœå¤±è´¥ï¼Œæ›´æ–°æ­¥éª¤ç»Ÿè®¡
    if task_log_step_index
        )
        stats = self.db.exec(statement).first()
        
        if not stats:
            stats = StepFailureStats(
                script_id=task_log.script_id,
                step_index=failed_step_index,
                step_name=failed_step_name
            )
        
        stats.total_count += 1
        if task_log.status == "failed":
            stats.failure_count += 1
            stats.last_failure_time = datetime.now()
            stats.last_error_message = error_message
 uration)
                stats.max_duration = max(stats.max_duration, task_log.duration)
        
        stats.updated_at = datetime.now()
        self.db.add(stats)
        self.db.commit()
    
    async def update_step_failure_stats(self, task_log: TaskLog, failed_step_index: int, failed_step_name: str, error_message: str):
        """æ›´æ–°æ­¥éª¤å¤±è´¥ç»Ÿè®¡"""
        statement = select(StepFailureStats).where(
            StepFailureStats.script_id == task_log.script_id,
            StepFailureStats.step_index == failedg.duration:
            if stats.total_executions == 1:
                stats.avg_duration = task_log.duration
                stats.min_duration = task_log.duration
                stats.max_duration = task_log.duration
            else:
                # è®¡ç®—æ–°çš„å¹³å‡å€¼
                total_duration = stats.avg_duration * (stats.total_executions - 1) + task_log.duration
                stats.avg_duration = total_duration / stats.total_executions
                stats.min_duration = min(stats.min_duration, task_log.driptExecutionStats(
                script_id=task_log.script_id,
                stat_date=today
            )
        
        # æ›´æ–°ç»Ÿè®¡
        stats.total_executions += 1
        if task_log.status == "success":
            stats.success_count += 1
        elif task_log.status == "failed":
            stats.failed_count += 1
        
        # è®¡ç®—æˆåŠŸç‡
        stats.success_rate = (stats.success_count / stats.total_executions * 100) if stats.total_executions > 0 else 0
        
        # æ›´æ–°æ‰§è¡Œæ—¶é•¿
        if task_lopy

class StatsService:
    def __init__(self, db: Session):
        self.db = db
    
    async def update_script_stats(self, task_log: TaskLog):
        """æ›´æ–°è„šæœ¬ç»Ÿè®¡æ•°æ®"""
        today = date.today()
        
        # è·å–æˆ–åˆ›å»ºä»Šæ—¥ç»Ÿè®¡
        statement = select(ScriptExecutionStats).where(
            ScriptExecutionStats.script_id == task_log.script_id,
            ScriptExecutionStats.stat_date == today
        )
        stats = self.db.exec(statement).first()
        
        if not stats:
            stats = Sc